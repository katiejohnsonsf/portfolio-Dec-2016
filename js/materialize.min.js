/*!
 * Materialize v0.97.7 (http://materializecss.com)
 * Copyright 2014-2015 Materialize
 * MIT License (https://raw.githubusercontent.com/Dogfalo/materialize/master/LICENSE)
 */; // t: current time,b: begInnIng value,c: change In value,d: duration jQuery.easing['jswing'] = jQuery.easing['swing']; jQuery.extend( jQuery.easing,{def:'easeOutQuad',swing: function (x,t,b,c,d) {
		//alert(jQuery.easing.default);
		return jQuery.easing[jQuery.easing.def](x,t,b,c,d); },easeInQuad: function (x,t,b,c,d) {
		return c*(t/=d) *t + b;
	},easeOutQuad: function (x,t,b,c,d) {
		return -c *(t/=d) *(t-2) + b;
	},easeInOutQuad: function (x,t,b,c,d) {
		if ((t/=d/2) < 1) return c/2*t*t + b;
		return -c/2 * ((--t) *(t-2) - 1) + b;
	},easeInCubic: function (x,t,b,c,d) {
		return c*(t/=d) *t*t + b;
	},easeOutCubic: function (x,t,b,c,d) {
		return c*((t=t/d-1) *t*t + 1) + b;
	},easeInOutCubic: function (x,t,b,c,d) {
		if ((t/=d/2) < 1) return c/2*t*t*t + b;
		return c/2*((t-=2) *t*t + 2) + b;
	},easeInQuart: function (x,t,b,c,d) {
		return c*(t/=d) *t*t*t + b;
	},easeOutQuart: function (x,t,b,c,d) {
		return -c * ((t=t/d-1) *t*t*t - 1) + b;
	},easeInOutQuart: function (x,t,b,c,d) {
		if ((t/=d/2) < 1) return c/2*t*t*t*t + b;
		return -c/2 * ((t-=2) *t*t*t - 2) + b;
	},easeInQuint: function (x,t,b,c,d) {
		return c*(t/=d) *t*t*t*t + b;
	},easeOutQuint: function (x,t,b,c,d) {
		return c*((t=t/d-1) *t*t*t*t + 1) + b;
	},easeInOutQuint: function (x,t,b,c,d) {
		if ((t/=d/2) < 1) return c/2*t*t*t*t*t + b;
		return c/2*((t-=2) *t*t*t*t + 2) + b;
	},easeInSine: function (x,t,b,c,d) {
		return -c * Math.cos(t/d * (Math.PI/2)) + c + b;
	},easeOutSine: function (x,t,b,c,d) {
		return c * Math.sin(t/d * (Math.PI/2)) + b;
	},easeInOutSine: function (x,t,b,c,d) {
		return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;
	},easeInExpo: function (x,t,b,c,d) {
		return (t==0) ? b : c * Math.pow(2,10 * (t/d - 1)) + b;
	},easeOutExpo: function (x,t,b,c,d) {
		return (t==d) ? b+c : c * (-Math.pow(2,-10 * t/d) + 1) + b;
	},easeInOutExpo: function (x,t,b,c,d) {
		if (t==0) return b;
		if (t==d) return b+c;
		if ((t/=d/2) < 1) return c/2 * Math.pow(2,10 * (t - 1)) + b;
		return c/2 * (-Math.pow(2,-10 * --t) + 2) + b;
	},easeInCirc: function (x,t,b,c,d) {
		return -c * (Math.sqrt(1 - (t/=d) *t) - 1) + b;
	},easeOutCirc: function (x,t,b,c,d) {
		return c * Math.sqrt(1 - (t=t/d-1) *t) + b;
	},easeInOutCirc: function (x,t,b,c,d) {
		if ((t/=d/2) < 1) return -c/2 * (Math.sqrt(1 - t*t) - 1) + b;
		return c/2 * (Math.sqrt(1 - (t-=2) *t) + 1) + b;
	},easeInElastic: function (x,t,b,c,d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b; if ((t/=d) ==1) return b+c; if (!p) p=d*.3;
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return -(a*Math.pow(2,10*(t-=1)) * Math.sin((t*d-s) *(2*Math.PI) /p)) + b;
	},easeOutElastic: function (x,t,b,c,d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b; if ((t/=d) ==1) return b+c; if (!p) p=d*.3;
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return a*Math.pow(2,-10*t) * Math.sin((t*d-s) *(2*Math.PI) /p) + c + b;
	},easeInOutElastic: function (x,t,b,c,d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b; if ((t/=d/2) ==2) return b+c; if (!p) p=d*(.3*1.5);
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin((t*d-s) *(2*Math.PI) /p)) + b;
		return a*Math.pow(2,-10*(t-=1)) * Math.sin((t*d-s) *(2*Math.PI) /p) *.5 + c + b;
	},easeInBack: function (x,t,b,c,d,s) {
		if (s == undefined) s = 1.70158;
		return c*(t/=d) *t*((s+1) *t - s) + b;
	},easeOutBack: function (x,t,b,c,d,s) {
		if (s == undefined) s = 1.70158;
		return c*((t=t/d-1) *t*((s+1) *t + s) + 1) + b;
	},easeInOutBack: function (x,t,b,c,d,s) {
		if (s == undefined) s = 1.70158;
		if ((t/=d/2) < 1) return c/2*(t*t*(((s*=(1.525)) +1) *t - s)) + b;
		return c/2*((t-=2) *t*(((s*=(1.525)) +1) *t + s) + 2) + b;
	},easeInBounce: function (x,t,b,c,d) {
		return c - jQuery.easing.easeOutBounce (x,d-t,0,c,d) + b;
	},easeOutBounce: function (x,t,b,c,d) {
		if ((t/=d) < (1/2.75)) {
			return c*(7.5625*t*t) + b;
		} else if (t < (2/2.75)) {
			return c*(7.5625*(t-=(1.5/2.75)) *t + .75) + b;
		} else if (t < (2.5/2.75)) {
			return c*(7.5625*(t-=(2.25/2.75)) *t + .9375) + b;
		} else {
			return c*(7.5625*(t-=(2.625/2.75)) *t + .984375) + b;
		}
	},easeInOutBounce: function (x,t,b,c,d) {
		if (t < d/2) return jQuery.easing.easeInBounce (x,t*2,0,c,d) * .5 + b;
		return jQuery.easing.easeOutBounce (x,t*2-d,0,c,d) * .5 + c*.5 + b;
	}},); ; // Custom Easing jQuery.extend( jQuery.easing{easeInOutMaterial:function (x,t,b,c,d) { if ((t/=d/2) < 1) return c/2*t*t + b; return c/4*((t-=2) *t*t + 2) + b; }}PickerConstructor._ ={group:function(groupObject) { var//Scope for the looped object loopObjectScope,//Create the nodes list nodesList = '',//The counter starts from the `min` counter = PickerConstructor._.trigger(groupObject.min,groupObject)//Loop from the `min` to `max`,incrementing by `i` for (; counter <= PickerConstructor._.trigger(groupObject.max,groupObject,[ counter ]); counter += groupObject.i) {//Trigger the `item` function within scope of the object loopObjectScope = PickerConstructor._.trigger(groupObject.item,groupObject,[ counter ])//Splice the subgroup and create nodes out of the sub nodes nodesList += PickerConstructor._.node(groupObject.node,loopObjectScope[ 0 ],// the node loopObjectScope[ 1 ],// the classes loopObjectScope[ 2 ] // the attributes) }//Return the list of nodes return nodesList },//group node: function(wrapper,item,klass,attribute) {//If the item is false-y,just return an empty string if (!item) return ''//If the item is an array,do a join item = $.isArray(item) ? item.join('') : item//Check for the class klass = klass ? ' class="' + klass + '"' : ''//Check for any attributes attribute = attribute ? ' ' + attribute : ''//Return the wrapped item return '<' + wrapper + klass + attribute + '>' + item + '</' + wrapper + '>' },//node lead: function(number) { return (number < 10 ? '0': '') + number },trigger: function(callback,scope,args) { return typeof callback == 'function' ? callback.apply(scope,args || []) : callback },digits: function(string) { return (/\d/) .test(string[ 1 ]) ? 2 : 1 },isDate: function(value) { return {}.toString.call(value) .indexOf('Date') > -1 && this.isInteger(value.getDate()) },isInteger: function(value) { return {}.toString.call(value) .indexOf('Number') > -1 && value % 1 === 0 },ariaAttr: ariaAttr}function ariaSet(element,attribute,value){element.setAttribute(
        (attribute == 'role' ? '':'aria-') + attribute,value)}DatePicker.prototype.validate = function( type,dateObject,options ){var calendar = this,

        // Keep a reference to the original date.
        originalDateObject = dateObject,

        // Make sure we have an interval.
        interval = options && options.interval ? options.interval:1,//Check if the calendar enabled dates are inverted. isFlippedBase = calendar.item.enable === -1,//Check if we have any enabled dates after/before now. hasEnabledBeforeTarget,hasEnabledAfterTarget,//The min & max limits. minLimitObject = calendar.item.min,maxLimitObject = calendar.item.max,//Check if we’ve reached the limit during shifting. reachedMin,reachedMax,//Check if the calendar is inverted and at least one weekday is enabled. hasEnabledWeekdays = isFlippedBase && calendar.item.disable.filter(function(value) { // If there’s a date,check where it is relative to the target. if ($.isArray(value)) { var dateTime = calendar.create(value) .pick if (dateTime < dateObject.pick) hasEnabledBeforeTarget = true else if (dateTime > dateObject.pick) hasEnabledAfterTarget = true } // Return only integers for enabled weekdays. return _.isInteger(value) }) .length//Cases to validate for://[1] Not inverted and date disabled.//[2] Inverted and some dates enabled.//[3] Not inverted and out of range.////Cases to **not** validate for://• Navigating months.//• Not inverted and date enabled.//• Inverted and all dates disabled.//• ..and anything else. if (!options || !options.nav) if ((!isFlippedBase && calendar.disabled(dateObject)) || (isFlippedBase && calendar.disabled(dateObject) && (hasEnabledWeekdays || hasEnabledBeforeTarget || hasEnabledAfterTarget)) || (!isFlippedBase && (dateObject.pick <= minLimitObject.pick || dateObject.pick >= maxLimitObject.pick))) {//When inverted,flip the direction if there aren’t any enabled weekdays//and there are no enabled dates in the direction of the interval. if (isFlippedBase && !hasEnabledWeekdays && ((!hasEnabledAfterTarget && interval > 0) || (!hasEnabledBeforeTarget && interval < 0))) { interval *= -1 }//Keep looping until we reach an enabled date. while (calendar.disabled(dateObject)) {//If we’ve looped into the next/prev month with a large interval,return to the original date and flatten the interval. if (Math.abs(interval) > 1 && (dateObject.month < originalDateObject.month || dateObject.month > originalDateObject.month)) { dateObject = originalDateObject interval = interval > 0 ? 1 : -1 }//If we’ve reached the min/max limit,reverse the direction,flatten the interval and set it to the limit. if (dateObject.pick <= minLimitObject.pick) { reachedMin = true interval = 1 dateObject = calendar.create([ minLimitObject.year,minLimitObject.month,minLimitObject.date + (dateObject.pick === minLimitObject.pick ? 0 : -1) ]) } else if (dateObject.pick >= maxLimitObject.pick) { reachedMax = true interval = -1 dateObject = calendar.create([ maxLimitObject.year,maxLimitObject.month,maxLimitObject.date + (dateObject.pick === maxLimitObject.pick ? 0 : 1) ]) }//If we’ve reached both limits,just break out of the loop. if (reachedMin && reachedMax) { break }//Finally,create the shifted date using the interval and keep looping. dateObject = calendar.create([ dateObject.year,dateObject.month,dateObject.date + interval ]) } }//endif//Return the date object settled on. return dateObject}DatePicker.prototype.isDateOverlap = function( one,two ){var calendar = this,
        firstDay = calendar.settings.firstDay ? 1:0//When we’re working with a weekday index,compare the days. if (_.isInteger(one) && (_.isDate(two) || $.isArray(two))) { one = one % 7 + firstDay return one === calendar.create(two) .day + 1 } if (_.isInteger(two) && (_.isDate(one) || $.isArray(one))) { two = two % 7 + firstDay return two === calendar.create(one) .day + 1 }//When we’re working with range objects,check if the ranges overlap. if ($.isPlainObject(one) && $.isPlainObject(two)) { return calendar.overlapRanges(one,two) } return false}DatePicker.prototype.flipEnable = function(val){var itemObject = this.item
    itemObject.enable = val || (itemObject.enable == -1 ? 1:-1)},//createMonthLabel // Create the year label. // Materialize modified createYearLabel = function(override){var focusedYear = viewsetObject.year,

            // If years selector is set to a literal "true", set it to 5. Otherwise
            // divide in half to get half before and half after focused year.
            numberYears = settings.selectYears === true ? 5:~~(settings.selectYears / 2)//If there are years to select,add a dropdown menu. if (numberYears) { var minYear = minLimitObject.year,maxYear = maxLimitObject.year,lowestYear = focusedYear - numberYears,highestYear = focusedYear + numberYears//If the min year is greater than the lowest year,increase the highest year//by the difference and set the lowest year to the min year. if (minYear > lowestYear) { highestYear += minYear - lowestYear lowestYear = minYear }//If the max year is less than the highest year,decrease the lowest year//by the lower of the two: available and needed years. Then set the//highest year to the max year. if (maxYear < highestYear) { var availableYears = lowestYear - minYear,neededYears = highestYear - maxYear lowestYear -= availableYears > neededYears ? neededYears : availableYears highestYear = maxYear } if (settings.selectYears && override == undefined) { return _.node('select',_.group({ min: lowestYear,max: highestYear,i: 1,node: 'option',item: function(loopedYear) { return [ // The looped year and no classes. loopedYear,0,// Set the value and selected index. 'value=' + loopedYear + (focusedYear == loopedYear ? ' selected' : '') ] } }),settings.klass.selectYear + ' browser-default',(isOpen ? '' : 'disabled') + ' ' + _.ariaAttr({ controls: calendar.$node[0].id + '_table' }) + ' ' + 'title="' + settings.labelYearSelect + '"') } }//Materialize modified if (override == "raw") return _.node('div',focusedYear)//Otherwise just return the year focused return _.node('div',focusedYear,settings.klass.year)}( jQuery ));


__ESCAPED_SOURCE_END_CLEAN_CSS__